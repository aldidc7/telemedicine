<?php

namespace App\Http\Controllers\Api;

use App\Http\Controllers\Controller;
use App\Models\Payment;
use App\Models\Invoice;
use App\Models\InvoiceItem;
use App\Models\TaxRecord;
use App\Models\Konsultasi;
use App\Services\PaymentService;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Str;

/**
 * ============================================
 * PAYMENT CONTROLLER
 * ============================================
 * 
 * Mengelola payment transactions & invoicing
 * 
 * ✓ Double payment prevention (idempotency keys)
 * ✓ Pessimistic locks on consultations
 * ✓ Atomic transactions (3 retries)
 * ✓ Distributed Redis locks
 * ✓ Full audit logging
 * 
 * Endpoints:
 * POST   /api/v1/payments - Create payment
 * GET    /api/v1/payments/{id} - Get payment details
 * POST   /api/v1/payments/{id}/confirm - Confirm payment
 * POST   /api/v1/payments/{id}/refund - Refund payment
 * GET    /api/v1/invoices/{id} - Get invoice
 * GET    /api/v1/invoices/{id}/download - Download invoice PDF
 * GET    /api/v1/payments/history - Payment history
 * POST   /api/v1/webhooks/payment - Stripe webhook
 */
class PaymentController extends Controller
{
    private PaymentService $paymentService;

    public function __construct(PaymentService $paymentService)
    {
        $this->paymentService = $paymentService;
    }
    /**
     * Create new payment for consultation
     * POST /api/v1/payments
     * 
     * Request Body:
     * {
     *   "consultation_id": 5,
     *   "amount": 5000.00,
     *   "payment_method": "stripe",
     *   "idempotency_key": "pay-1234567890-uuid" (generated by frontend)
     * }
     * 
     * Response 201 (New payment):
     * {
     *   "data": {
     *     "type": "new",
     *     "payment_id": 123,
     *     "payment": {...},
     *     "invoice": {...}
     *   }
     * }
     * 
     * Response 409 (Duplicate):
     * {
     *   "data": {
     *     "type": "existing",
     *     "payment_id": 123,
     *     "status": "completed"
     *   }
     * }
     */
    public function create(Request $request)
    {
        $validated = $request->validate([
            'consultation_id' => 'required|exists:konsultasis,id',
            'amount' => 'required|numeric|min:1000',
            'payment_method' => 'required|in:stripe,gcash,bank_transfer,e_wallet',
            'idempotency_key' => 'required|string|max:255',
        ]);

        $user = Auth::user();
        $idempotencyKey = $validated['idempotency_key'];

        try {
            // Use PaymentService untuk process payment dengan protection
            $result = $this->paymentService->processPayment(
                userId: $user->id,
                consultationId: $validated['consultation_id'],
                amount: $validated['amount'],
                paymentMethod: $validated['payment_method'],
                idempotencyKey: $idempotencyKey
            );

            // If duplicate request detected
            if ($result['type'] === 'existing') {
                return response()->json([
                    'data' => [
                        'type' => 'existing',
                        'payment_id' => $result['payment_id'],
                        'status' => $result['status'],
                        'message' => 'Pembayaran sudah dibuat sebelumnya',
                    ],
                    'message' => 'Duplicate payment request detected',
                ], 409); // Conflict status
            }

            // New payment created
            return response()->json([
                'data' => [
                    'type' => 'new',
                    'payment_id' => $result['payment_id'],
                    'payment' => $result['payment'],
                    'invoice' => $result['invoice'],
                ],
                'message' => 'Pembayaran berhasil dibuat',
            ], 201);
        } catch (\Exception $e) {
            // Handle specific errors
            if (str_contains($e->getMessage(), 'Unauthorized')) {
                return response()->json([
                    'message' => 'Unauthorized - Konsultasi bukan milik Anda',
                    'error' => $e->getMessage(),
                ], 403);
            }

            if (str_contains($e->getMessage(), 'lock')) {
                return response()->json([
                    'message' => 'Permintaan pembayaran sedang diproses. Silakan coba lagi.',
                    'error' => 'Lock acquisition timeout',
                ], 503); // Service Unavailable
            }

            return response()->json([
                'message' => 'Gagal membuat pembayaran',
                'error' => $e->getMessage(),
            ], 500);
        }
    }

    /**
     * Get payment details
     * GET /api/v1/payments/{id}
     */
    public function show($id)
    {
        $user = Auth::user();

        try {
            $payment = $this->paymentService->getPaymentDetails(
                paymentId: (int)$id,
                userId: (int)$user->id,
                isAdmin: $user->isAdmin()
            );

            if (!$payment) {
                return response()->json([
                    'message' => 'Pembayaran tidak ditemukan',
                ], 404);
            }

            return response()->json([
                'data' => [
                    'payment' => $payment,
                    'status_label' => $payment->getStatusLabel(),
                    'method_label' => $payment->getMethodLabel(),
                    'formatted_amount' => $payment->getFormattedAmount(),
                ],
            ]);
        } catch (\Exception $e) {
            return response()->json([
                'message' => 'Unauthorized access to payment',
                'error' => $e->getMessage(),
            ], 403);
        }
    }

    /**
     * Confirm payment (after Stripe/GCash callback)
     * POST /api/v1/payments/{id}/confirm
     * 
     * Request Body:
     * {
     *   "transaction_id": "stripe_pi_1234567890",
     *   "receipt_url": "https://..."
     * }
     * 
     * Uses pessimistic locking to ensure atomic confirmation
     * Returns 409 Conflict if payment already confirmed
     */
    public function confirm(Request $request, $id)
    {
        $validated = $request->validate([
            'transaction_id' => 'required|string|max:255',
            'receipt_url' => 'nullable|url',
        ]);

        try {
            // Use PaymentService dengan atomic locking
            $payment = $this->paymentService->confirmPayment(
                paymentId: (int)$id,
                transactionId: $validated['transaction_id'],
                receiptUrl: $validated['receipt_url'] ?? null
            );

            return response()->json([
                'data' => [
                    'payment' => $payment->load('invoices', 'taxRecords'),
                    'status' => 'completed',
                ],
                'message' => 'Pembayaran berhasil dikonfirmasi',
            ]);
        } catch (\Exception $e) {
            // Handle specific error cases
            if (str_contains($e->getMessage(), 'not found')) {
                return response()->json([
                    'message' => 'Pembayaran tidak ditemukan',
                    'error' => $e->getMessage(),
                ], 404);
            }

            if (
                str_contains($e->getMessage(), 'status') ||
                str_contains($e->getMessage(), 'already')
            ) {
                return response()->json([
                    'message' => 'Status pembayaran tidak valid untuk confirm',
                    'error' => $e->getMessage(),
                ], 409); // Conflict
            }

            if (str_contains($e->getMessage(), 'lock')) {
                return response()->json([
                    'message' => 'Pembayaran sedang dikonfirmasi. Silakan coba lagi.',
                    'error' => 'Lock timeout',
                ], 503);
            }

            return response()->json([
                'message' => 'Gagal mengkonfirmasi pembayaran',
                'error' => $e->getMessage(),
            ], 500);
        }
    }

    /**
     * Refund payment
     * POST /api/v1/payments/{id}/refund
     * 
     * Request Body:
     * {
     *   "amount": 5000.00 (optional, if omitted = full refund),
     *   "reason": "Pembeli membatalkan konsultasi"
     * }
     * 
     * Uses pessimistic locking to ensure atomic refund
     */
    public function refund(Request $request, $id)
    {
        $validated = $request->validate([
            'amount' => 'nullable|numeric|min:1000',
            'reason' => 'required|string|min:10|max:500',
        ]);

        $user = Auth::user();

        try {
            // Use PaymentService dengan atomic locking
            $payment = $this->paymentService->refundPayment(
                paymentId: (int)$id,
                amount: $validated['amount'] ?? null,
                reason: $validated['reason']
            );

            // Check authorization
            if ($payment->user_id !== $user->id && !$user->isAdmin()) {
                return response()->json([
                    'message' => 'Unauthorized access',
                ], 403);
            }

            return response()->json([
                'data' => [
                    'payment' => $payment,
                    'refund_amount' => $payment->refund_amount,
                ],
                'message' => 'Refund berhasil diproses',
            ]);
        } catch (\Exception $e) {
            if (str_contains($e->getMessage(), 'not found')) {
                return response()->json([
                    'message' => 'Pembayaran tidak ditemukan',
                    'error' => $e->getMessage(),
                ], 404);
            }

            if (
                str_contains($e->getMessage(), 'completed') ||
                str_contains($e->getMessage(), 'exceeds')
            ) {
                return response()->json([
                    'message' => 'Refund tidak dapat diproses',
                    'error' => $e->getMessage(),
                ], 400);
            }

            return response()->json([
                'message' => 'Gagal memproses refund',
                'error' => $e->getMessage(),
            ], 500);
        }
    }

    /**
     * Get payment history
     * GET /api/v1/payments/history
     */
    public function history(Request $request)
    {
        $user = Auth::user();

        try {
            $payments = $this->paymentService->getUserPaymentHistory(
                userId: $user->id,
                perPage: $request->input('per_page', 15)
            );

            return response()->json([
                'data' => $payments->map(function ($payment) {
                    return [
                        'id' => $payment->id,
                        'amount' => $payment->getFormattedAmount(),
                        'status' => $payment->getStatusLabel(),
                        'method' => $payment->getMethodLabel(),
                        'invoice_number' => $payment->invoices()->first()?->invoice_number,
                        'created_at' => $payment->created_at->toDateString(),
                    ];
                }),
                'links' => $payments->links(),
                'pagination' => [
                    'current_page' => $payments->currentPage(),
                    'total' => $payments->total(),
                    'per_page' => $payments->perPage(),
                ],
            ]);
        } catch (\Exception $e) {
            return response()->json([
                'message' => 'Gagal mengambil riwayat pembayaran',
                'error' => $e->getMessage(),
            ], 500);
        }
    }

    /**
     * Stripe webhook callback
     * POST /api/v1/webhooks/payment
     */
    public function webhook(Request $request)
    {
        // Verify webhook signature dari Stripe
        $signature = $request->header('Stripe-Signature');
        // TODO: Implement Stripe signature verification

        $event = json_decode($request->getContent(), true);

        if ($event['type'] === 'payment_intent.succeeded') {
            $paymentIntentId = $event['data']['object']['id'];

            $payment = Payment::where('transaction_id', $paymentIntentId)->first();
            if ($payment) {
                $payment->markCompleted($paymentIntentId);

                // Mark invoice as paid
                $invoice = $payment->invoices()->first();
                if ($invoice) {
                    $invoice->markPaid();
                }
            }
        }

        return response()->json(['success' => true]);
    }

    // ==================== HELPER METHODS ====================

    /**
     * Calculate taxes for payment
     */
    private function calculateTaxes(Payment $payment)
    {
        // PPN (VAT) - 11% standard rate
        $ppnAmount = TaxRecord::calculate($payment->amount, TaxRecord::TYPE_PPN);
        TaxRecord::create([
            'payment_id' => $payment->id,
            'tax_type' => TaxRecord::TYPE_PPN,
            'tax_rate' => TaxRecord::RATES[TaxRecord::TYPE_PPN],
            'base_amount' => $payment->amount,
            'tax_amount' => $ppnAmount,
            'status' => TaxRecord::STATUS_CALCULATED,
        ]);

        // PPh (Personal Income Tax) - 15% untuk professional services
        $pphAmount = TaxRecord::calculate($payment->amount, TaxRecord::TYPE_PPH);
        TaxRecord::create([
            'payment_id' => $payment->id,
            'tax_type' => TaxRecord::TYPE_PPH,
            'tax_rate' => TaxRecord::RATES[TaxRecord::TYPE_PPH],
            'base_amount' => $payment->amount,
            'tax_amount' => $pphAmount,
            'status' => TaxRecord::STATUS_CALCULATED,
        ]);
    }

    /**
     * Generate invoice from payment
     */
    private function generateInvoice(Payment $payment): Invoice
    {
        $totalTax = $payment->taxRecords()->sum('tax_amount');
        $total = $payment->amount + $totalTax;

        $invoice = Invoice::create([
            'payment_id' => $payment->id,
            'user_id' => $payment->user_id,
            'invoice_number' => Invoice::generateNumber(),
            'invoice_date' => today(),
            'due_date' => today()->addDays(7),
            'subtotal' => $payment->amount,
            'tax_amount' => $totalTax,
            'discount_amount' => 0,
            'total_amount' => $total,
            'status' => Invoice::STATUS_DRAFT,
        ]);

        // Add invoice items
        if ($payment->consultation_id) {
            InvoiceItem::create([
                'invoice_id' => $invoice->id,
                'description' => 'Konsultasi Medis',
                'item_type' => InvoiceItem::TYPE_CONSULTATION,
                'quantity' => 1,
                'unit_price' => $payment->amount,
                'amount' => $payment->amount,
            ]);
        }

        if ($payment->emergency_id) {
            InvoiceItem::create([
                'invoice_id' => $invoice->id,
                'description' => 'Biaya Penanganan Darurat',
                'item_type' => InvoiceItem::TYPE_EMERGENCY,
                'quantity' => 1,
                'unit_price' => 500000, // Fixed emergency fee
                'amount' => 500000,
            ]);
        }

        return $invoice;
    }
}
